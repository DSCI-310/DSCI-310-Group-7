import unittest
import numpy as np
import pandas as pd
import statsmodels.api as sm
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier

from src.std_acc import *

# load and preprocess the dataset that will be used in following tests
dataset_iris = sm.datasets.get_rdataset(dataname='iris', package='datasets')
df_iris = dataset_iris.data
feature = df_iris[["Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width"]]
X = feature
y = df_iris["Species"]

yhat = np.zeros(10)

# function input for the test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=4)
for n in range(1, 50):
    # Train Model and Predict
    decTree = DecisionTreeClassifier(criterion="entropy", max_depth=n)
    decTree.fit(X_train, y_train)
    yhat = decTree.predict(X_test)

# expected out for the tests

std_acc_validexpected = np.zeros((50 - 1))

std_acc_edgeexpected = np.zeros((2-1))


for n in range(1, 50):
    std_acc_validexpected[n - 1] = np.std(yhat == y_test) / np.sqrt(yhat.shape[0])

for n in range(1, 2):
    std_acc_edgeexpected[n-1] = np.std(yhat == y_test) / np.sqrt(yhat.shape[0])

std_acc_invalidexpected = "The model is invalid."




def test_stdacc():
    std_acc_validinput = stdAcc(yhat, y_test, 50)
    std_acc_invalidinput = stdAcc(yhat, y_test, m)
    std_acc_edgeinput = stdAcc(yhat, y_test, 2)
    
    # test if the output generated by std_acc() is expected given valid inputs
    if pd.DataFrame(std_acc_validinput).equals(pd.DataFrame(std_acc_validexpected)):
        assert True
    else:
        assert False

    # test if notification will be generated given the invalid inputs
    if std_acc_invalidexpected.equals(std_acc_invalidinput):
        assert True
    else:
        assert False

    # test edge case input
    if pd.DataFrame(std_acc).equals(pd.DataFrame(std_acc_edgeexpected)):
        assert True
    else:
        assert False
